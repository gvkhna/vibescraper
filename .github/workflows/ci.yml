name: Build, Test & Deploy

on:
  push:
    branches: ['main']
  workflow_dispatch:

permissions:
  id-token: write
  contents: read
  deployments: write
  packages: write
  attestations: write

env:
  DO_NOT_TRACK: 1
  ASTRO_TELEMETRY_DISABLED: 1
  BETTER_AUTH_TELEMETRY: 0

jobs:
  build_test_publish:
    name: Build, Test and Publish
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build complete development environment image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./packages/website/Dockerfile
          target: build
          load: true
          tags: vibescraper:build
          cache-from: |
            type=gha,scope=prod
            type=registry,ref=ghcr.io/${{ github.repository }}:latest
          cache-to: type=gha,mode=max,scope=prod

      - name: Build production runtime dist stage for testing
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./packages/website/Dockerfile
          load: true
          tags: vibescraper:test
          cache-from: |
            type=gha,scope=prod
            type=registry,ref=ghcr.io/${{ github.repository }}:latest
          cache-to: type=gha,mode=max,scope=prod

      - name: Run unit and integration tests
        run: |
          docker run \
            -e CI=true \
            -e DEBUG='*' \
            -e DOCKER_IMAGE=vibescraper:test \
            -v $PWD:$PWD \
            -v /var/run/docker.sock:/var/run/docker.sock \
            vibescraper:build \
            pnpm run test

      - name: Declare docker image meta tags
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            name=${{ github.repository }}
            name=ghcr.io/${{ github.repository }}
          tags: |
            type=semver,pattern={{version}}
            type=edge,branch=main
            type=sha
          flavor: |
            latest=true

      - name: Auth to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Auth to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Publish production image (multi-arch)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./packages/website/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: |
            type=gha,scope=prod
            type=registry,ref=ghcr.io/${{ github.repository }}:latest
          cache-to: |
            type=gha,mode=max,scope=prod

  deploy_production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build_test_publish
    environment: production
    if: success()
    env:
      DOKPLOY_API_KEY: ${{ secrets.DOKPLOY_API_KEY }}
      DOKPLOY_APPLICATION_ID: ${{ secrets.DOKPLOY_APPLICATION_ID }}
      DOKPLOY_API_HOSTNAME: ${{ secrets.DOKPLOY_API_HOSTNAME }}
      DOKPLOY_BACKUP_ID: ${{ secrets.DOKPLOY_BACKUP_ID }}
      PUBLIC_HOSTNAME: ${{ vars.PUBLIC_HOSTNAME }}
    steps:
      - name: Backup database via Dokploy API
        if: ${{ env.DOKPLOY_API_HOSTNAME != '' }}
        run: |
          # Mask sensitive values
          echo "::add-mask::$DOKPLOY_API_HOSTNAME"
          echo "::add-mask::$DOKPLOY_APPLICATION_ID"
          echo "::add-mask::$DOKPLOY_API_KEY"
          echo "::add-mask::$DOKPLOY_BACKUP_ID"

          echo "Triggering Postgres backup..."

          set +e
          curl --fail --silent -X POST \
            -H 'accept: application/json' \
            -H 'Content-Type: application/json' \
            -H "x-api-key: $DOKPLOY_API_KEY" \
            -d '{"backupId": "'"$DOKPLOY_BACKUP_ID"'"}' \
            "$DOKPLOY_API_HOSTNAME/backup.manualBackupPostgres" \
            > /dev/null 2>&1

          BACKUP_EXIT_CODE=$?
          set -e

          if [ $BACKUP_EXIT_CODE -eq 0 ]; then
            echo "✓ Backup triggered successfully"
          else
            echo "✗ Failed to trigger backup (error code: $BACKUP_EXIT_CODE)"
            exit 1
          fi

      - name: Trigger redeploy via Dokploy API
        if: ${{ env.DOKPLOY_API_HOSTNAME != '' }}
        run: |
          # Mask sensitive values
          echo "::add-mask::$DOKPLOY_API_HOSTNAME"
          echo "::add-mask::$DOKPLOY_APPLICATION_ID"
          echo "::add-mask::$DOKPLOY_API_KEY"
          echo "::add-mask::$DOKPLOY_BACKUP_ID"

          echo "Triggering container redeploy..."

          # Use set +e to prevent immediate exit on error
          set +e

          # Trigger redeploy
          curl --fail --silent -X POST \
            -H 'accept: application/json' \
            -H 'Content-Type: application/json' \
            -H "x-api-key: $DOKPLOY_API_KEY" \
            -d '{"applicationId": "'"$DOKPLOY_APPLICATION_ID"'"}' \
            "$DOKPLOY_API_HOSTNAME/application.redeploy" \
            > /dev/null 2>&1

          CURL_EXIT_CODE=$?
          set -e

          if [ $CURL_EXIT_CODE -eq 0 ]; then
            echo "✓ Deployment triggered successfully"
          else
            echo "✗ Failed to trigger deployment (error code: $CURL_EXIT_CODE)"
            exit 1
          fi

      - name: Wait for deployment health check
        if: ${{ env.DOKPLOY_API_HOSTNAME != '' }}
        run: |
          echo "Waiting for deployment to complete..."
          timeout=300  # maximum wait time in seconds
          interval=10  # interval between health checks
          elapsed=0

          while [ $elapsed -lt $timeout ]; do
            if curl -fsS "${PUBLIC_HOSTNAME}/health" >/dev/null 2>&1; then
              echo "✓ Deployment completed successfully"
              exit 0
            fi

            # Show progress without revealing details
            if [ $((elapsed % 30)) -eq 0 ] && [ $elapsed -gt 0 ]; then
              echo "  Still waiting... (${elapsed}s elapsed)"
            fi

            sleep $interval
            elapsed=$((elapsed + interval))
          done

          echo "✗ Deployment health check timed out after ${timeout} seconds"
          exit 1
