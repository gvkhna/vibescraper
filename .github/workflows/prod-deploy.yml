name: Prod Deploy Website, App & Migrate DB

on:
  push:
    branches: ['main']
  workflow_dispatch:

permissions:
  id-token: write
  contents: read
  deployments: write
  packages: write
  attestations: write

env:
  BUILD_PATH: '.'
  DO_NOT_TRACK: 1
  ASTRO_TELEMETRY_DISABLED: 1
  BETTER_AUTH_TELEMETRY: 0

jobs:
  build_publish:
    name: Build and Publish Container
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install asdf
        uses: asdf-vm/actions/setup@v4

      - name: Install asdf plugins
        uses: asdf-vm/actions/plugins-add@v4

      - name: Install asdf tools
        run: |
          asdf install nodejs
          asdf install pnpm
          asdf install bun
          asdf reshim

      - name: Get pnpm cache directory path
        id: pnpm-cache-dir-path
        run: echo "dir=$(pnpm store path)" >> $GITHUB_OUTPUT

      # Cache PNPM store on lockfile and workspace config hash
      - name: Cache PNPM store
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache-dir-path.outputs.dir }}
          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml', '**/package.json', 'pnpm-workspace.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-

      - name: Verify installed tools
        run: |
          which node && node --version
          which pnpm && pnpm --version
          which bun && bun --version
          echo "PATH: $PATH"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        working-directory: ${{ env.BUILD_PATH }}

      - name: Build website with Turbo
        env:
          DEBUG_COLORS: ${{ vars.DEBUG_COLORS }}
          DEBUG_HIDE_DATE: ${{ vars.DEBUG_HIDE_DATE }}
          DEBUG: ${{ vars.DEBUG }}
          NODE_ENV: ${{ vars.NODE_ENV }}
          TMP_DIR: ${{ vars.TMP_DIR }}
        run: |
          bun run build
          bun run deploy:website
        working-directory: ${{ env.BUILD_PATH }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image for testing
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./packages/website/Dockerfile
          platforms: linux/amd64
          load: true
          tags: vibescraper-test:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Run smoke test
        run: |
          # Configuration
          IMAGE_NAME="vibescraper-test:latest"
          CONTAINER_NAME="vibescraper-smoke-test"
          DB_CONTAINER_NAME="postgres-smoke-test"
          NETWORK_NAME="vibescraper-test-network"
          PORT="4321"
          HEALTH_URL="http://localhost:${PORT}/health"

          # Create network
          echo "Creating test network..."
          docker network create "$NETWORK_NAME"

          # Start PostgreSQL
          echo "Starting PostgreSQL..."
          docker run -d \
            --name "$DB_CONTAINER_NAME" \
            --network "$NETWORK_NAME" \
            --network-alias postgres \
            -e POSTGRES_USER="testuser" \
            -e POSTGRES_PASSWORD="testpass" \
            -e POSTGRES_DB="testdb" \
            postgres:16-alpine

          # Wait for PostgreSQL
          echo "Waiting for PostgreSQL..."
          for i in {1..30}; do
            if docker exec "$DB_CONTAINER_NAME" pg_isready -U testuser -d testdb 2>/dev/null; then
              echo "PostgreSQL is ready"
              break
            fi
            sleep 1
          done

          # Start app container
          echo "Starting app container..."
          docker run -d \
            --name "$CONTAINER_NAME" \
            --network "$NETWORK_NAME" \
            -p "${PORT}:${PORT}" \
            --env-file .env.example \
            "$IMAGE_NAME"

          # Wait and test health endpoint
          echo "Testing health endpoint..."
          sleep 5

          for i in {1..10}; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL" 2>/dev/null || echo "000")
            echo "Attempt $i/10: HTTP $HTTP_CODE"

            if [ "$HTTP_CODE" = "200" ]; then
              echo "Smoke test PASSED"
              exit 0
            elif [ "$HTTP_CODE" != "000" ]; then
              echo "Smoke test FAILED - HTTP $HTTP_CODE"
              docker logs "$CONTAINER_NAME" --tail 50
              exit 1
            fi

            sleep 3
          done

          echo "Smoke test FAILED - Health endpoint not responding"
          docker logs "$CONTAINER_NAME" --tail 50
          exit 1

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push multi-platform Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./packages/website/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ghcr.io/${{ github.repository }}:latest
            ghcr.io/${{ github.repository }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy_production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build_publish
    environment: production
    if: success()
    env:
      DOKPLOY_API_KEY: ${{ secrets.DOKPLOY_API_KEY }}
      DOKPLOY_APPLICATION_ID: ${{ secrets.DOKPLOY_APPLICATION_ID }}
      DOKPLOY_API_HOSTNAME: ${{ secrets.DOKPLOY_API_HOSTNAME }}
      PUBLIC_HOSTNAME: ${{ vars.PUBLIC_HOSTNAME }}
    steps:
      - name: Trigger redeploy via Dokploy API
        if: ${{ env.DOKPLOY_API_HOSTNAME != '' }}
        run: |
          # Mask sensitive values
          echo "::add-mask::$DOKPLOY_API_HOSTNAME"
          echo "::add-mask::$DOKPLOY_APPLICATION_ID"
          echo "::add-mask::$DOKPLOY_API_KEY"
          
          echo "Triggering container redeploy..."
          
          # Use set +e to prevent immediate exit on error
          set +e
          
          # Capture curl exit code without showing any output or errors
          curl --fail --silent -X POST \
            -H 'accept: application/json' \
            -H 'Content-Type: application/json' \
            -H "x-api-key: $DOKPLOY_API_KEY" \
            -d '{"applicationId": "'"$DOKPLOY_APPLICATION_ID"'"}' \
            "$DOKPLOY_API_HOSTNAME/application.redeploy" \
            > /dev/null 2>&1
          
          CURL_EXIT_CODE=$?
          set -e
          
          if [ $CURL_EXIT_CODE -eq 0 ]; then
            echo "✓ Deployment triggered successfully"
          else
            echo "✗ Failed to trigger deployment (error code: $CURL_EXIT_CODE)"
            # Don't show curl error details, just the exit code
            exit 1
          fi

      - name: Wait for container health
        if: ${{ env.DOKPLOY_API_HOSTNAME != '' }}
        run: |
          echo "Waiting for deployment to complete..."
          timeout=300  # maximum wait time in seconds
          interval=10  # interval between health checks
          elapsed=0
          
          while [ $elapsed -lt $timeout ]; do
            if curl -fsS "${PUBLIC_HOSTNAME}/health" >/dev/null 2>&1; then
              echo "✓ Deployment completed successfully"
              exit 0
            fi
            
            # Show progress without revealing details
            if [ $((elapsed % 30)) -eq 0 ] && [ $elapsed -gt 0 ]; then
              echo "  Still waiting... (${elapsed}s elapsed)"
            fi
            
            sleep $interval
            elapsed=$((elapsed + interval))
          done
          
          echo "✗ Deployment health check timed out after ${timeout} seconds"
          exit 1
