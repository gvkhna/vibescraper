name: Build, Test & Deploy

on:
  push:
    branches: ['main']
  workflow_dispatch:

permissions:
  id-token: write
  contents: read
  deployments: write
  packages: write
  attestations: write

env:
  DO_NOT_TRACK: 1
  ASTRO_TELEMETRY_DISABLED: 1
  BETTER_AUTH_TELEMETRY: 0

jobs:
  build_test_publish:
    name: Build, Test and Publish
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Build only up to the 'build' stage for testing
      - name: Build test environment
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./packages/website/Dockerfile
          target: build
          load: true
          tags: vibescraper:test
          cache-from: type=gha,scope=prod
          cache-to: type=gha,mode=max,scope=prod

      # Build the full production image
      - name: Build production image for testing
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./packages/website/Dockerfile
          load: true
          tags: vibescraper:latest
          cache-from: type=gha,scope=prod
          cache-to: type=gha,mode=max,scope=prod

      # Run integration tests using the build stage container
      - name: Run integration tests
        run: |
          # Run tests inside the build stage container
          docker run --rm \
            -e CI=true \
            -e DEBUG='*' \
            -e DOCKER_IMAGE=vibescraper:latest \
            -v $PWD:$PWD -w $PWD \
            -v /var/run/docker.sock:/var/run/docker.sock \
            vibescraper:test \
            sh -c "cd packages/server-test && pnpm run test"

      # Login to container registry
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Build and push production image (multi-arch)
      - name: Build and push production image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./packages/website/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ghcr.io/${{ github.repository }}:latest
            ghcr.io/${{ github.repository }}:${{ github.sha }}
          cache-from: type=gha,scope=prod
          cache-to: type=gha,mode=max,scope=prod

  deploy_production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build_test_publish
    environment: production
    if: success()
    env:
      DOKPLOY_API_KEY: ${{ secrets.DOKPLOY_API_KEY }}
      DOKPLOY_APPLICATION_ID: ${{ secrets.DOKPLOY_APPLICATION_ID }}
      DOKPLOY_API_HOSTNAME: ${{ secrets.DOKPLOY_API_HOSTNAME }}
      PUBLIC_HOSTNAME: ${{ vars.PUBLIC_HOSTNAME }}
    steps:
      - name: Trigger redeploy via Dokploy API
        if: ${{ env.DOKPLOY_API_HOSTNAME != '' }}
        run: |
          # Mask sensitive values
          echo "::add-mask::$DOKPLOY_API_HOSTNAME"
          echo "::add-mask::$DOKPLOY_APPLICATION_ID"
          echo "::add-mask::$DOKPLOY_API_KEY"

          echo "Triggering container redeploy..."

          # Use set +e to prevent immediate exit on error
          set +e

          # Trigger redeploy
          curl --fail --silent -X POST \
            -H 'accept: application/json' \
            -H 'Content-Type: application/json' \
            -H "x-api-key: $DOKPLOY_API_KEY" \
            -d '{"applicationId": "'"$DOKPLOY_APPLICATION_ID"'"}' \
            "$DOKPLOY_API_HOSTNAME/application.redeploy" \
            > /dev/null 2>&1

          CURL_EXIT_CODE=$?
          set -e

          if [ $CURL_EXIT_CODE -eq 0 ]; then
            echo "✓ Deployment triggered successfully"
          else
            echo "✗ Failed to trigger deployment (error code: $CURL_EXIT_CODE)"
            exit 1
          fi

      - name: Wait for deployment health check
        if: ${{ env.DOKPLOY_API_HOSTNAME != '' }}
        run: |
          echo "Waiting for deployment to complete..."
          timeout=300  # maximum wait time in seconds
          interval=10  # interval between health checks
          elapsed=0

          while [ $elapsed -lt $timeout ]; do
            if curl -fsS "${PUBLIC_HOSTNAME}/health" >/dev/null 2>&1; then
              echo "✓ Deployment completed successfully"
              exit 0
            fi

            # Show progress without revealing details
            if [ $((elapsed % 30)) -eq 0 ] && [ $elapsed -gt 0 ]; then
              echo "  Still waiting... (${elapsed}s elapsed)"
            fi

            sleep $interval
            elapsed=$((elapsed + interval))
          done

          echo "✗ Deployment health check timed out after ${timeout} seconds"
          exit 1
